
1
00:00:37,700 --> 00:00:41,700
Let's imagine we're starting with the word planet! OK, I'm just

2
00:00:41,700 --> 00:00:45,700
going to go through the first couple of letters, at the moment, so P and L. I'm going to end up drawing them

3
00:00:45,700 --> 00:00:49,700
in a circle, if you're wondering why I'm drawing them like this. So, we have P and L, and we want to say

4
00:00:49,700 --> 00:00:53,700
are those letters duplicated? Well, you just do one comparison between P and

5
00:00:53,700 --> 00:00:57,700
L right? Pretty simple! So, let's now put some more letters in

6
00:00:57,700 --> 00:01:01,700
A an N. I'll put them all in for now.

7
00:01:01,700 --> 00:01:05,700
E and T. I'm putting them in a circle, you'll see why in a second, it just helps me draw a particular type of diagram.

8
00:01:05,700 --> 00:01:09,700
So, if I now want to compare the letters in

9
00:01:09,700 --> 00:01:13,700
P, L, and A, to see if any of them are repeating, then I can pair

10
00:01:13,700 --> 00:01:17,700
P to L and then I could compare A to L and A to

11
00:01:17,700 --> 00:01:21,700
P, doing now three comparisons! If I wanted a

12
00:01:21,700 --> 00:01:25,700
P L A N, PLAN, then I could add to this three another

13
00:01:25,700 --> 00:01:29,700
one, two, three, to get six comparisons. If I had

14
00:01:29,700 --> 00:01:33,700
PLANE, then I could be adding to the six,

15
00:01:33,700 --> 00:01:37,700
or I could be adding another one, two, three, four, so we're up

16
00:01:37,700 --> 00:01:41,700
to ten. And then, if I had a T on the end, I could be adding another one,

17
00:01:41,700 --> 00:01:45,700
two, three, four, five, for a

18
00:01:45,700 --> 00:01:49,700
grand total of fifteen different comparisons here,

19
00:01:49,700 --> 00:01:53,700
which we need to do. Another way of looking at that

20
00:01:53,700 --> 00:01:57,700
is like this! What we're saying is, that as the size of the

21
00:01:57,700 --> 00:02:01,700
word, so Word.Length

22
00:02:01,700 --> 00:02:05,700
...

23
00:02:05,700 --> 00:02:09,700
... goes up from say 0 to, I don't know, say

24
00:02:09,700 --> 00:02:13,700
10 letters, the question is, how many comparisons do we need

25
00:02:13,700 --> 00:02:17,700
to do, and how fast does this go up? This is

26
00:02:17,700 --> 00:02:21,700
to do with the order, how fast is this? Well look, this is how I

27
00:02:21,700 --> 00:02:25,700
reason about how fast it is. If we write the word Planet a couple of

28
00:02:25,700 --> 00:02:29,700
times, like this: PLANET, and then, write it

29
00:02:29,700 --> 00:02:33,700
again across a grid. The short answer,

30
00:02:33,700 --> 00:02:37,700
by the way, is n squared, for those of you who are experienced, mathematical,

31
00:02:37,700 --> 00:02:41,700
and/or impatient, but let me explain why it's rougly

32
00:02:41,700 --> 00:02:45,700
n squared. It's not also exactly n squared. This little formula we're going to work out

33
00:02:45,700 --> 00:02:49,700
is going to be quite helpful, because it helps you work out how many pairs there are between things.

34
00:02:49,700 --> 00:02:53,700
By the way, this is not also the fastest way of doing this, just

35
00:02:53,700 --> 00:02:57,700
rub some of that rubbish out. OK cool! So, let's quickly talk about the fact that we're not

36
00:02:57,700 --> 00:03:01,700
interested in comparing letters to themselves like this, we're interested

37
00:03:01,700 --> 00:03:05,700
in the two triangles. We have say a red triangle here,

38
00:03:05,700 --> 00:03:09,700
and that red triangle is all of the instances in which

39
00:03:09,700 --> 00:03:13,700
we say compare L to P, A to P, A to N, etc.

40
00:03:13,700 --> 00:03:17,700
And that covers all of these lines, actually, and then, you've got the lines going the other way,

41
00:03:17,700 --> 00:03:21,700
which are all of these elements up here. Let me make it a different color,

42
00:03:21,700 --> 00:03:25,700
which is a say green triangle.

43
00:03:25,700 --> 00:03:29,700
OK, so how many comparisons do we have to do

44
00:03:29,700 --> 00:03:33,700
in general? Well, if we have two letters we do one comparison. If we have three letters we have

45
00:03:33,700 --> 00:03:37,700
three, if we have four we do more, and at five letters, like this, it looks like we'd do

46
00:03:37,700 --> 00:03:41,700
fifteen comparison. The way you work it out is you say, look if the number of letters...

47
00:03:41,700 --> 00:03:45,700
This is the case n = 6 here, so we're here somewhere on the graph,

48
00:03:45,700 --> 00:03:49,700
then the number of squares in the grid is 6 times 6.

49
00:03:49,700 --> 00:03:53,700
So that's n squared: n squared,

50
00:03:53,700 --> 00:03:57,700
number of squares. We need to take off n squares, for the diagonal,

51
00:03:57,700 --> 00:04:01,700
and then, we need to divide the whole thing by two, because n squared

52
00:04:01,700 --> 00:04:05,700
- n was the area of these two triangles. You then

53
00:04:05,700 --> 00:04:09,700
say, well we only need one of these, it doesn't matter which way around we compare. So, n squared

54
00:04:09,700 --> 00:04:13,700
- n over 2, and that's also the same as saying n into (n-1)

55
00:04:13,700 --> 00:04:17,700
over 2 or a million other ways of writing it. The point about this

56
00:04:17,700 --> 00:04:21,700
really, that I want to get across, is that the speed that this

57
00:04:21,700 --> 00:04:25,700
goes up, the worst offender to the speed of which

58
00:04:25,700 --> 00:04:29,700
the comparisons increases with the word length is the n squared bit. So,

59
00:04:29,700 --> 00:04:33,700
what we say is, this thing is of order n squared. So,

60
00:04:33,700 --> 00:04:37,700
we're saying it's like this: At a value of 10

61
00:04:37,700 --> 00:04:41,700
comparisons, you'd have 10 squared which is 100 - 10, which is 90 over

62
00:04:41,700 --> 00:04:45,700
2 is 45. So, you'd have 45 comparisons there.

63
00:04:45,700 --> 00:04:49,700
At 6 you would have

64
00:04:49,700 --> 00:04:53,700
15 comparisons, which we've just counted, because you'd have 6.

65
00:04:53,700 --> 00:04:57,700
We'll just use this insistent color here. You'd have 6 times 6 is 36,

66
00:04:57,700 --> 00:05:01,700
minus 6 is 30, and 30 over 2 is 15, so you get 15 there.

67
00:05:01,700 --> 00:05:05,700
So, you can see that this algorithm, that you could easily come up with and write a nested

68
00:05:05,700 --> 00:05:09,700
for loop for, goes up pretty fast. It goes up to what we call

69
00:05:09,700 --> 00:05:13,700
order n squared, which means that if you double the number of

70
00:05:13,700 --> 00:05:17,700
letters... I know there's only like the longest isogram in the

71
00:05:17,700 --> 00:05:21,700
English language is like however many letters, we'll look it up in a minute, but the point

72
00:05:21,700 --> 00:05:25,700
is to start thinking about this early. This does not scale well, as this problem

73
00:05:25,700 --> 00:05:29,700
gets bigger. Now, in our case it doesn't matter, but it's an important point to consider

74
00:05:29,700 --> 00:05:33,700
how fast it scales. So, is there a faster way?

75
00:05:33,700 --> 00:05:37,700
Well, if you're smart you may realize that, actually what you could do

76
00:05:37,700 --> 00:05:41,700
with a particular word is, you could say well why don't we just sort

77
00:05:41,700 --> 00:05:45,700
the letters. So, we have the word planet,

78
00:05:45,700 --> 00:05:49,700
and that is an isogram, but we could sort the letters. So, we go a

79
00:05:49,700 --> 00:05:53,700
e... I don't know. l m n o p q r s t?

80
00:05:53,700 --> 00:05:57,700
So, a e l n

81
00:05:57,700 --> 00:06:01,700
p t. OK fine! So, that is an isogram, because we can

82
00:06:01,700 --> 00:06:05,700
go through this... We can sort it, we'll talk about how fast sorting is in a minute, and then, we can go through

83
00:06:05,700 --> 00:06:09,700
very quickly once and say OK there's no duplicates. How about if

84
00:06:09,700 --> 00:06:13,700
I had, I don't know, boom?

85
00:06:13,700 --> 00:06:17,700
That actually already is sorted, well it's nearly sorted. If you sorted

86
00:06:17,700 --> 00:06:21,700
it you'd get bmoo, and you'd go through this and go

87
00:06:21,700 --> 00:06:25,700
ah; as soon as you get to a duplicate letter, then it is not an isogram.

88
00:06:25,700 --> 00:06:29,700
So, how fast is this way of doing it? Well, the first question is, how fast can

89
00:06:29,700 --> 00:06:33,700
you sort? Well, let's take a look! Let's go something like "wiki sorting

90
00:06:33,700 --> 00:06:37,700
algorithm". An algorithm is not an ex U.S.

91
00:06:37,700 --> 00:06:41,700
vice president's dance style, rather a recipe for solving a problem.

92
00:06:41,700 --> 00:06:45,700
Now, you'll get more than you need here, when you go to

93
00:06:45,700 --> 00:06:49,700
Wikipedia, but what you'll see is a very common theme, is that the best you'll ever do

94
00:06:49,700 --> 00:06:53,700
when sorting is something called n log n. In some cases, you can do what we call n,

95
00:06:53,700 --> 00:06:57,700
which means that as the size of the word goes up the number

96
00:06:57,700 --> 00:07:01,700
of operations you do goes up with it, in the case of in, but n log n is generally,

97
00:07:01,700 --> 00:07:05,700
in the general case, the best you can do. So, what does n

98
00:07:05,700 --> 00:07:09,700
log n look like? Well, it's worse than n. If we have

99
00:07:09,700 --> 00:07:13,700
a chance, what we have... In fact, why don't I just use Wikipedia. Well, not Wikipedia! Oh, not Wikipedia,

100
00:07:13,700 --> 00:07:17,700
WolframAlpha! Let's use WolframAlpha to show you how these two things compare! So, we go n

101
00:07:17,700 --> 00:07:21,700
squared is, the thing that we talked about before and I gave you a little plot

102
00:07:21,700 --> 00:07:25,700
of. I can't be bothered to plot n log n, so I'm going to go versus n log n for

103
00:07:25,700 --> 00:07:29,700
n = 2 is the shortest word we care about, 2 say 17 is the longest

104
00:07:29,700 --> 00:07:33,700
word we care about. Let's look at the performance of these two algorithms compared,

105
00:07:33,700 --> 00:07:37,700
so there's the comparison! Our previous algorithm, where we did

106
00:07:37,700 --> 00:07:41,700
all the pairings was n squared, but this sorting algorithm,

107
00:07:41,700 --> 00:07:45,700
apparently, can be done in n log n, which is much quicker. Look how much quicker it is, especially for long

108
00:07:45,700 --> 00:07:49,700
words, and if the problem got bigger, then it would get faster and faster.

109
00:07:49,700 --> 00:07:53,700
So, this guy here, where we do firstly a sort,

110
00:07:53,700 --> 00:07:57,700
then just

111
00:07:57,700 --> 00:08:01,700
check for pairs... Oops, that's not very neat

112
00:08:01,700 --> 00:08:05,700
is it! ... Is n log n

113
00:08:05,700 --> 00:08:09,700
+, because afterwards you then just go through all of the pairs

114
00:08:09,700 --> 00:08:13,700
1, 2, 3, which takes in operations. You basically go through all of

115
00:08:13,700 --> 00:08:17,700
this in pairs there, there, there, which takes n.

116
00:08:17,700 --> 00:08:21,700
So, it's n log n + n. We don't care about this, because it's much smaller than n

117
00:08:21,700 --> 00:08:25,700
log n. If you don't believe me, let's add this to the plot, then we get our complete

118
00:08:25,700 --> 00:08:29,700
plot. So, vs n and this shows us all the three

119
00:08:29,700 --> 00:08:33,700
options for the challenge you're about to have, which is I want you to guess how fast it is

120
00:08:33,700 --> 00:08:37,700
possible to detect an isogram. Here is n, it's as fast as we could possibly go!

121
00:08:37,700 --> 00:08:41,700
By the way, I think it's reasonable to reason that you can't go any faster than n,

122
00:08:41,700 --> 00:08:45,700
i. e., we need to look at every letter. The best you could possibly

123
00:08:45,700 --> 00:08:49,700
do is of order, and it might be a little different to n, some little overhead either end.

124
00:08:49,700 --> 00:08:53,700
But in general terms, you need to look at every letter to be sure there are no duplicates, right. I

125
00:08:53,700 --> 00:08:57,700
think that that's a reasonable assumption, so I don't think we're making this guy go any faster than

126
00:08:57,700 --> 00:09:01,700
n down here, which is scaling beautifully. It may be as slow as

127
00:09:01,700 --> 00:09:05,700
n log n, where we do a sort, and then, we go through the sorted string

128
00:09:05,700 --> 00:09:09,700
and check for duplicates. And we could use this kind of brute force method here, which seems

129
00:09:09,700 --> 00:09:13,700
smart, when I first created it ah, but it's actually pretty slow because it's of order n

130
00:09:13,700 --> 00:09:17,700
squared. So, this chart gives you the dramatic difference between the speed of those!

131
00:09:17,700 --> 00:09:21,700
What I want you to do as a challenge now is as follows! I want

132
00:09:21,700 --> 00:09:25,700
you to work out what order you think IsIsogram() can be written at

133
00:09:25,700 --> 00:09:29,700
best. Vote for order n, order n log n, or oder n squared.

134
00:09:29,700 --> 00:09:33,700
Share your vote in the discussions, and explain why you think that's as fast as it can possibly go.

135
00:09:33,700 --> 00:09:37,700
And then, carry on watching the video, and I'll share what I think the fastest

136
00:09:37,700 --> 00:09:41,700
algorithm is for this.

137
00:09:41,700 --> 00:09:45,700
Welcome back! Now look, I just want to congratulate you for

138
00:09:45,700 --> 00:09:49,700
doing what is basically very proper computer science at

139
00:09:49,700 --> 00:09:53,700
this point. I'm really impressed, you've done a great job even

140
00:09:53,700 --> 00:09:57,700
conceptualizing this stuff, so it's grown-up things. So, I think

141
00:09:57,700 --> 00:10:01,700
we can do this in order n! How do we think we can do it in order n? I think we can do it in order

142
00:10:01,700 --> 00:10:05,700
n, using something called a hash table and it's pretty simple. Let me save a copy

143
00:10:05,700 --> 00:10:09,700
of this as n log n1. Yep, that's

144
00:10:09,700 --> 00:10:13,700
fine, and then, just delete it all and

145
00:10:13,700 --> 00:10:17,700
show you what I mean. It's actually very simple! What I think we could do

146
00:10:17,700 --> 00:10:21,700
is, we could have a word. Let's just go Planet again, oops!

147
00:10:21,700 --> 00:10:25,700
And what we could have over here is a table of all

148
00:10:25,700 --> 00:10:29,700
the letters in the alphabet, A, B, C, D, E, so on

149
00:10:29,700 --> 00:10:33,700
to Z. [Laughs] And I better have a P in here somewhere

150
00:10:33,700 --> 00:10:37,700
and a T maybe. OK, you get the idea! And what I do is, as I go through

151
00:10:37,700 --> 00:10:41,700
this word I just tally the number of these things

152
00:10:41,700 --> 00:10:45,700
that I have. How many P's do I have? I go through it, I get to P, I say 1 here in this tally!

153
00:10:45,700 --> 00:10:49,700
I get to L, I say there's an L, wherever that is! Here 1! I get to A,

154
00:10:49,700 --> 00:10:53,700
and I say 1, I get to n and I say 1, and I keep going! And the

155
00:10:53,700 --> 00:10:57,700
algorithm is that provided the moment I get a 2 we're done!

156
00:10:57,700 --> 00:11:01,700
It's not an isogram! So, if I put the word Boom in again,

157
00:11:01,700 --> 00:11:05,700
then we have a different tally but you get the idea. I go B

158
00:11:05,700 --> 00:11:09,700
and then wherever O is, L, M, N, O, P, in here I go O!

159
00:11:09,700 --> 00:11:13,700
And then, I go O again! Uh Oh! Now, suddenly because there are two

160
00:11:13,700 --> 00:11:17,700
O's it's not a tally! I can stop, and the worst if I'd have to do is go through the entire

161
00:11:17,700 --> 00:11:21,700
word. So, this guy is of order

162
00:11:21,700 --> 00:11:25,700
n, which is hugely faster for big problems than

163
00:11:25,700 --> 00:11:29,700
these other guys! So, that's the fastest we can do IsIsogram()!

164
00:11:29,700 --> 00:11:33,700
It's too orders better than I initially thought! I thought I was being

165
00:11:33,700 --> 00:11:37,700
smart with my funny diagram thingy I showed you in the beginning. I wasn't, somebody pointed out to me I

166
00:11:37,700 --> 00:11:41,700
could easily do a sort, and then, we got humbled again when we thought about it and realized

167
00:11:41,700 --> 00:11:45,700
you could just hash it! So, awesome introduction

168
00:11:45,700 --> 00:11:49,533
to performance! See you soon!

